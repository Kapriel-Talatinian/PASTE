import yfinance as yf
import telebot
import pandas as pd
import numpy as np
from ta.trend import ADXIndicator, MACD
from ta.momentum import StochasticOscillator
import time

# Configuration du bot Telegram
TELEGRAM_BOT_TOKEN = '7343754821:AAFxzk453jSeqQhz2IqxFKfOTV9_txYwKls'
CHAT_ID = '-4508141227'
bot = telebot.TeleBot(TELEGRAM_BOT_TOKEN)

# Actifs surveill√©s
SYMBOLS = {'XAU/USD': 'GC=F', 'NDX/USD': '^NDX'}
TIMEFRAME = '1h'

# Fonction pour r√©cup√©rer les donn√©es de Yahoo Finance
def get_data(symbol):
    yf_symbol = SYMBOLS[symbol]
    df = yf.download(yf_symbol, period='14d', interval='1h')
    
    if df.empty:
        return df  # √âviter les erreurs si pas de donn√©es

    df = df[['Open', 'High', 'Low', 'Close', 'Volume']].dropna()
    
    for col in df.columns:
        df[col] = df[col].astype(float).squeeze()
    
    return df

# Fonction pour calculer les indicateurs
def calculate_indicators(df):
    if df.empty:
        return df  # √âviter une erreur si DataFrame vide
    
    adx = ADXIndicator(high=df['High'], low=df['Low'], close=df['Close'], window=14)
    df['adx'] = adx.adx().astype(float).squeeze()
    df['di+'] = adx.adx_pos().astype(float).squeeze()
    df['di-'] = adx.adx_neg().astype(float).squeeze()
    
    macd = MACD(close=df['Close'])
    df['macd'] = macd.macd().astype(float).squeeze()
    df['macd_signal'] = macd.macd_signal().astype(float).squeeze()
    df['macd_cross'] = np.where(df['macd'] > df['macd_signal'], 1, -1)
    
    stoch = StochasticOscillator(high=df['High'], low=df['Low'], close=df['Close'], window=14, smooth_window=3)
    df['stoch_k'] = stoch.stoch().astype(float).squeeze()
    df['stoch_d'] = stoch.stoch_signal().astype(float).squeeze()
    
    df['cog'] = df['Close'].rolling(window=10).mean().astype(float).squeeze()
    
    return df.dropna()

# V√©rification des signaux
def check_signals(df):
    latest = df.iloc[-1]
    previous = df.iloc[-2]
    
    macd_bullish = previous['macd_cross'] == -1 and latest['macd_cross'] == 1
    stoch_bullish = previous['stoch_k'] < previous['stoch_d'] and latest['stoch_k'] > latest['stoch_d']
    cog_bullish = previous['Close'] < previous['cog'] and latest['Close'] > latest['cog']
    
    macd_bearish = previous['macd_cross'] == 1 and latest['macd_cross'] == -1
    stoch_bearish = previous['stoch_k'] > previous['stoch_d'] and latest['stoch_k'] < latest['stoch_d']
    cog_bearish = previous['Close'] > previous['cog'] and latest['Close'] < latest['cog']
    
    bullish_count = sum([macd_bullish, stoch_bullish, cog_bullish])
    bearish_count = sum([macd_bearish, stoch_bearish, cog_bearish])
    
    adxr_trend_buy = latest['di+'] > latest['di-']
    adxr_trend_sell = latest['di-'] > latest['di+']
    
    signal = None
    if bullish_count >= 2 and adxr_trend_buy:
        signal = "BUY"
    elif bearish_count >= 2 and adxr_trend_sell:
        signal = "SELL"
    
    return signal

# Fonction principale
def main():
    while True:
        for symbol in SYMBOLS.keys():
            df = get_data(symbol)
            df = calculate_indicators(df)
            
            if not df.empty:
                signal = check_signals(df)
                
                if signal:
                    message = f'üì¢ Signal {signal} d√©tect√© sur {symbol} ({TIMEFRAME})\n‚ö° 2 indicateurs align√©s + ADXR confirm√©'
                    bot.send_message(CHAT_ID, message)
        
        time.sleep(60)  # V√©rifie les signaux toutes les minutes

# Ex√©cuter le bot
if __name__ == '__main__':
    main()
